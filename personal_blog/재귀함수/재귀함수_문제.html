<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 자연수로 이루어진 리스트(배열)을 입력받고, 리스트의 합을 리턴하는 함수 'arrsum'을 작성해라.
        /*
        수도코드 
        먼저 함수의 전달인자로 넣어볼 배열이 하나 필요
        결과를 담을 변수 하나 필요
        반복하는 횟수를 정하기 위헤 인자값의 length를 담고 -- 해줄 변수 하나 필요
        */
        function arrSum (arr) {
        // 빈 배열을 받았을 때 0을 리턴하는 조건문
        //   --> 가장 작은 문제를 해결하는 코드 & 재귀를 멈추는 코드
        if (arr.length === 0) {
            return 0 // 여기서 arrSum의 값에 영향을 주기 때문에 잘 생각해야 한다. ex. arr=['a','b','c']일때 return 값은 'abc0' 
        }

        // 배열의 첫 요소 + 나머지 요소가 담긴 배열을 받는 arrSum 함수
        //   --> 재귀(자기 자신을 호출)를 통해 문제를 작게 쪼개나가는 코드
            return arr.shift() + arrSum(arr)
            // shift() => 첫번째 요소를 제거하고, 제거된 요소를 반환한다. ( 원본 배열의 길이에 영향을 준다. )
            // 첫번째 요소 + arrSum(arr) 여기서 arr 는 첫번째 요소가 제거된 하나적은 arr가 된다. 
            // 두번째 실행될 때 두번째 요소까지 제거 => arr[0]+arr[1]+arrSum(arr) 여기서 arr 는 1번째 요소까지 제거된 arr 이다.
            // 세번째 실행될 때 세번재 요소까지 제거 => arr[0]+arr[1]+arr[2]+arrSum(arr) 여기서 arr 는 2번째 요소까지 제거된 arr 이다.

            // 이렇게 가다보면 조건문인 arr.length === 0 인 경우가 나오는데, 이때 0을 리턴하고, 최종적으로 arr 의 값들이 합쳐진 값이 나온다.
        }
        console.log(arrSum(['a','b','c']))

        // ---------------------------------------------------------------------------------------------------------------------------------
// 참고자료) function recursive(input1, input2, ...) {
            //   // base case : 문제를 더 이상 쪼갤 수 없는 경우
            //   if (문제를 더 이상 쪼갤 수 없을 경우) {
            //     return 단순한 문제의 해답;
            //   }

            //   // recursive case : 그렇지 않은 경우
            //   return 더 작은 문제로 새롭게 정의된 문제
            // }

        // 문제 : 자연수를 입력받고, 입력받은 수부터 1까지의 자연수를 모두 곱한 값을 리턴하는 재귀 함수 `fac` 을 작성하세요.
        // 1. 문제를 좀 더 작게 쪼갠다.
        // => 만약 입력받는 값이 5 라고 한다면,, 5*(a-1) 의 값이다. 그러면 let a = 5 라고 한다면 
        // 2. 1번과 같은 방식으로 문제가 더 작아지지 않을 때 까지 가장 작은 단위로 문제를 쪼갠다.
        // => 가장 작은 단위 : 5*(a-1)*(a-2)*(a-3)*(a-4) 이다. a-5를 하게 되면 어떤 값을 곱해서 0이 나오니 그건 pass 하도록 한다.
        // 3. 가장 작은 단위의 문제를 풂으로써 전체 문제를 해결한다. 
        // 그렇다면,, a*(a-i)를 해주고, i을 점점 높여서, 조건문으로 a-1 === i 같으면 리턴해주면 될꺼같다. 

        function fac(num){
            let a = 0
            if(num === 1){
                return 1
            }
            console.log(num)
            a++
            return num*fac(num-a)
        }

    </script>
</body>
</html>